## 익명 클래스 vs 람다 정리

### **주요 차이점**

**익명 클래스**
- 새로운 클래스를 정의해서 객체 생성하는 방식
- 여러 메서드 구현 가능
- 내부에 상태(필드) 가질 수 있음
- `this`는 익명 클래스 자체를 가리킴

**람다**
- 함수형 인터페이스만 구현 (메서드 하나만)
- 상태 없이 기능만 제공
- `this`는 외부 클래스 인스턴스를 가리킴
- 문법 간결하고 읽기 쉬움

### **생성 방식 (내부 동작)**

**익명 클래스**
- 익명 클래스는 새로운 클래스를 정의하여 객체를 생성하는 방식
- 컴파일 시 새로운 내부 클래스로 변환됨
- 예를 들어 `OuterClass$1.class` 같이 이름이 지정된 클래스 파일이 생성됨
- 클래스가 메모리 상에서 별도로 관리되므로 약간의 추가 오버헤드 발생
- 해당 클래스 파일을 JVM에 불러서 사용하는 과정이 필요함

**람다**
- 람다는 내부적으로 `invokeDynamic`이라는 메커니즘을 사용
- 컴파일 타임에 실제 클래스 파일을 생성하지 않음
- 런타임 시점에서 동적으로 필요한 코드를 처리함
- 컴파일 시점에 별도의 클래스 파일이 생성되지 않음
- 자바를 실행하는 실행 시점에 동적으로 필요한 코드를 처리함

**람다 컴파일 과정 예시 (실제와는 다를 수 있음)**
```java
// 원본 코드
Function<String, Integer> function = x -> x.length();

// 컴파일 후 (대략적인 변환 과정)
Function<String, Integer> function = 람다 인스턴스 생성(구현 코드는 lambda1() 연결)

// 람다를 private 메서드로 추가
private Integer lambda1(String x) {
    return x.length();
}
```

- 컴파일 단계에서 람다를 별도의 클래스로 만드는 것이 아니라 private 메서드로 만들어 숨겨둠 (자바 내부에서 발생하는 과정으로, 코드를 직접 확인하기는 어려움)
- 실행 시점에 동적으로 람다 인스턴스를 생성하고, 해당 인스턴스의 구현 코드로 앞서 만든 `lambda1()` 메서드가 호출되도록 연결함
- 따라서 람다는 익명 클래스보다 메모리 관리가 더 효율적이며, 생성된 클래스 파일이 없으므로 클래스 파일 관리의 복잡성도 줄어듦

### **사용 기준**

**익명 클래스 쓸 때**
- 메서드 여러 개 구현해야 할 때
- 상태(필드) 관리가 필요할 때
- 복잡한 인터페이스 구현할 때

**람다 쓸 때**
- 함수형 인터페이스 구현할 때
- 코드 간결하게 하고 싶을 때
- 상태 관리 필요 없을 때

### **결론**
자바 8 이후로는 웬만하면 람다 쓰는 게 좋다.

다만 상태 관리하거나 메서드 여러 개 구현해야 할 때만 익명 클래스 사용하면 된다.
(실무 관점에서 익명 클래스와 람다의 성능 차이는 거의 없다고 보면 된다.)