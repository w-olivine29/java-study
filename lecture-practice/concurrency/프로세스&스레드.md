### **1. 멀티태스킹과 멀티프로세싱의 원리**

**단일 프로그램 실행의 한계**

- 초창기 컴퓨터는 한 번에 하나의 프로그램만 실행 가능
- 음악을 들으며 문서 작성하는 등의 동시 작업이 불가능했음

**멀티태스킹의 동작 원리**

- **시분할(Time Sharing) 기법**: 약 0.01초(10ms) 단위로 프로그램들을 번갈아 실행
- 현대 CPU의 초당 수십억 번 연산으로 인해 사용자는 동시 실행으로 인식
- 애니메이션과 같은 원리 (초당 30-60장의 사진이 연속 동작으로 보임)

**멀티프로세싱과의 차이점**

- **멀티프로세싱**: 하드웨어 관점 (여러 CPU 코어 활용)
- **멀티태스킹**: 소프트웨어 관점 (운영체제의 스케줄링)

---
### **2. 프로세스와 스레드의 구조**

**프로세스의 특징**

- 실행 중인 프로그램의 인스턴스 (클래스와 인스턴스 관계와 유사)
- **독립적인 메모리 공간**: 코드 섹션, 데이터 섹션, 힙, 스택
- **격리된 실행**: 하나의 프로세스 충돌이 다른 프로세스에 영향 없음
- 프로세스 간 직접적인 메모리 접근 불가

**스레드의 특징**

- 프로세스 내에서 실행되는 **실제 작업 단위**
- **메모리 공유**: 같은 프로세스의 코드, 데이터, 힙을 공유
- **개별 스택**: 각 스레드는 독립적인 스택 영역 보유
- 프로세스는 최소 1개 이상의 스레드를 반드시 포함

**프로그램 실행의 본질**

- 프로그램 실행 = 코드를 순서대로 한 줄씩 실행하는 것
- 스레드가 코드를 "실처럼 꿰면서" 위에서 아래로 실행
- main() 메서드부터 시작해서 순차적으로 진행

---
### **3. 멀티스레드가 필요한 이유와 예시**

**실생활 예시**

- **워드 프로그램**: 문서 편집 + 자동 저장 + 맞춤법 검사
- **유튜브**: 영상 재생 + 댓글 입력
- 하나의 프로그램 내에서도 여러 작업이 동시에 필요

**운영체제 관점에서의 구조**

```
워드 프로그램 (프로세스A)
├── 스레드1: 문서 편집
├── 스레드2: 자동 저장  
└── 스레드3: 맞춤법 검사

유튜브 (프로세스B)
├── 스레드1: 영상 재생
└── 스레드2: 댓글 처리
```


---
### **4. 스케줄링의 세부 동작**

**단일 코어 스케줄링**

- 운영체제 내부의 **스케줄링 큐**에서 스레드들이 대기
- 스레드를 큐에서 꺼내 → CPU 실행 → 일정 시간 후 다시 큐에 삽입
- 순환적으로 모든 스레드가 CPU 시간을 할당받음

**멀티 코어 스케줄링**

- 물리적으로 진짜 동시에 여러 스레드 실행 가능
- CPU 코어 수만큼 병렬 처리 + 나머지는 시분할 처리
- 전체적인 성능 향상과 진정한 병렬 처리 구현

---
### **5. 컨텍스트 스위칭의 비용과 영향**

**컨텍스트 스위칭 과정**

1. 현재 스레드의 실행 상태(레지스터, 변수 등)를 메모리에 저장
2. 다음 스레드의 저장된 상태를 CPU로 복원
3. 새로운 스레드 실행 시작

**비용 발생 사례**

- **1~10,000 더하기 문제**를 스레드 2개로 분할
- **CPU 2개**: 병렬 처리로 2배 빠른 성능
- **CPU 1개**: 컨텍스트 스위칭 비용 > 단일 스레드가 더 효율적

**효율성 고려사항**

- 컨텍스트 스위칭 시간은 아주 짧지만, 스레드가 많으면 누적 비용 증가
- 멀티스레드가 항상 효율적이지는 않음

---
### **6. 실무에서의 최적 스레드 수 결정**

**CPU 바운드 작업의 특징**

- **정의**: CPU 연산 능력을 집중적으로 사용하는 작업
- **예시**: 복잡한 수학 연산, 데이터 분석, 비디오 인코딩, 과학적 시뮬레이션
- **최적 스레드 수**: CPU 코어 수 + 1개
- **이유**: CPU를 거의 100% 사용하므로 컨텍스트 스위칭 최소화가 중요

**I/O 바운드 작업의 특징**

- **정의**: 입출력 작업 대기 시간이 많은 작업
- **예시**: 데이터베이스 쿼리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 대기
- **특징**: CPU는 상대적으로 유휴 상태, 스레드가 대기 시간이 많음
- **최적 스레드 수**: CPU 코어 수보다 훨씬 많이 (성능 테스트로 최적값 결정)

---
### **7. 웹 애플리케이션 서버 사례 분석**

**일반적인 웹 서버 환경**

- 사용자 요청 1개 = 스레드 1개 필요
- 각 스레드가 CPU를 1%만 사용하고 99%는 데이터베이스 응답 대기

**잘못된 설정의 문제점**

- **CPU 4개 + 스레드 4개**: 동시 사용자 4명만 처리, CPU 4%만 사용
- **서버 성능 2배 업그레이드**: 여전히 사용자 4명, CPU 2%만 사용 (비효율)

**올바른 설정**

- **CPU 4개 + 스레드 100개**: 동시 사용자 100명 처리, CPU 100% 활용
- 성능 테스트를 통해 최적의 스레드 수 결정 필요

---
### **8. 핵심 실무 교훈**

**스레드 수 결정 원칙**

1. **작업 유형 분석**: CPU 바운드 vs I/O 바운드 파악
2. **성능 테스트**: 실제 환경에서 최적값 측정
3. **모니터링**: CPU 사용률과 응답 시간 지속적 관찰

**흔한 실무 실수**

- 하드웨어 성능 문제로 오인하여 불필요한 장비 업그레이드
- 스레드 수를 CPU 코어 수에만 맞추어 I/O 바운드 작업에서 성능 저하
- 컨텍스트 스위칭 비용을 고려하지 않은 과도한 스레드 생성

**결론적 관점** 멀티스레드는 강력한 성능 향상 도구이지만, 작업의 특성을 정확히 이해하고 적절한 설계를 통해서만 그 효과를 극대화할 수 있다.
특히 현대 웹 애플리케이션처럼 I/O 바운드 작업이 많은 환경에서는 전통적인 CPU 중심 사고에서 벗어나 새로운 접근이 필요