
# JVM 메모리 구조
![JVM메모리구조](JVM%20메모리%20구조.jpg)

### Method Area

- JVM이 시작될 때 생성되는 공간으로, **클래스 로딩 시 초기화되는 정보**를 저장하는 영역

- 저장되는 대상

    - 인터페이스에 대한 런타임 상수 풀(Runtime Constant Pool)

    - 멤버 변수(필드) 정보

    - 클래스 변수(static 변수)

    - 생성자(Constructor)

    - 메서드(Method) 정의 및 바이트코드

- 해당 정보들은 JVM이 실행되고 클래스가 로드될 때 메서드 영역에 적재되며, 프로그램이 종료될 때 함께 사라짐


---

### Stack Area

- **메서드 호출 시 생성되는 스택 프레임**이 저장되는 영역

    - 메서드 실행이 완료되면 해당 스택 프레임은 소멸

- 메모리의 높은 주소에서 낮은 주소로 할당

- LIFO(후입선출, Last-In First-Out) 방식으로 작동

- 각 스레드마다 독립적으로 생성되며, 지역 변수와 파라미터 등이 저장됨


---

### Heap Area

- 모든 클래스의 **객체(인스턴스)** 가 저장되는 영역

- 런타임 시에 동적으로 할당되는 공간으로, JVM이 관리

- 동적으로 변화하는 데이터들이 저장되는 기본 영역

- 메모리의 낮은 주소에서 높은 주소 방향으로 할당

- 힙에 있는 객체 중에서 스택에서 참조하지 않는 객체는 GC(Garbage Collector)의 대상이 됨


---

### PC Register

- 스레드가 시작될 때 생성되며, 현재 실행 중인 **JVM 명령어의 주소**를 저장하는 공간

- "프로그램이 실행된다"는 것은 CPU가 명령어를 순차적으로 수행하는 과정을 의미함

- CPU 입장에서 자바 프로그램은 JVM 위에서 실행되는 명령어 집합에 불과하며, CPU가 직접 자바 바이트코드를 처리하지 않음

    - 따라서 JVM은 현재 실행 중인 명령어 주소를 PC Register에 저장하고, 이를 CPU에 제공

- 예: 특정 스레드가 자바 메서드를 실행 중이라면, 그 메서드의 바이트코드 명령어 주소가 PC Register에 기록됨

- 만약 네이티브 코드(C, C++ 등)를 실행해야 한다면, PC Register는 자바 명령어를 제공할 수 없기 때문에 **Undefined 상태**가 되고, 이때 **Native Method Stack**이 사용됨


---

### Native Method Stack

- 자바 외의 언어로 작성된 코드를 실행하기 위한 스택

- JNI(Java Native Interface)를 통해 호출되는 네이티브 메서드가 이 영역을 사용

- 네이티브 코드 실행 시 필요한 매개변수, 지역 변수 등이 저장되며, JVM 바이트코드와 상호작용할 수 있도록 지원


---
## 요약


- **Method Area** → 클래스 정보, 메서드, static 변수

- **Stack** → 메서드 호출 스택 프레임, 지역 변수

- **Heap** → 객체 인스턴스 저장소

- **PC Register** → 현재 실행 중인 명령어 추적

- **Native Method Stack** → 네이티브 코드 실행 지원


---
# JVM 힙 메모리 구조와 GC 동작

JVM의 힙 메모리는 객체의 생명주기를 효율적으로 관리하기 위해 **세대별 GC(Generational GC)** 개념을 기반으로 설계

즉, 대부분의 객체는 금방 사라지고(짧은 생명주기), 일부 객체만 오래 살아남는다는 가정 하에 메모리를 Young / Old 세대로 나눠 관리하는 방식

---

## 공통 원리 (Generational GC)

선형 구조와 체스판 구조 모두 다음 개념은 동일하게 적용

- **Young Generation**

    - 새로 생성된 객체가 위치하는 공간

    - Eden → Survivor 영역을 거치면서 살아남은 객체는 age 값이 올라감

    - 일정 age 이상 누적되면 Old Generation으로 이동 (Promotion)

    - 이 영역에서 발생하는 GC를 **Minor GC**라고 부름

- **Old Generation**

    - 여러 차례 GC를 견디고 살아남은, 수명이 긴 객체가 위치

    - 이 영역에서 발생하는 GC를 **Major GC**라고 부름

- **프로모션(Promotion)**

    - Young Generation에서 여러 번 살아남은 객체가 Old Generation으로 이동하는 과정

- **GC와 Stop-the-World**

    - GC 실행 시 모든 스레드가 일시 정지됨

    - 따라서 GC는 자주 일어나도, 너무 드물게 일어나도 성능 문제가 발생함

        - 너무 자주 → 성능 저하

        - 너무 드물게 → 메모리 비효율, 누수처럼 보이는 현상



## 선형 구조 (전통적인 GC: Parallel, CMS 등)
![힙 메모리 구조(선형)](힙 메모리 구조(선형).jpg)

- 힙이 **Young / Old 세대**로 물리적으로 고정된 구조

- Eden, Survivor, Old Generation이 각각 **정해진 위치**에 존재

- GC도 해당 영역 단위로 수행됨

- 구현이 단순하고 이해하기 쉽지만, 힙이 커질수록 Stop-the-World 시간이 길어지는 단점이 있음

- 비교적 소규모~중규모 애플리케이션에 적합

---
## 체스판 구조 (G1 GC, Java 9~ 디폴트)

![힙 메모리 구조(체스판)](힙 메모리 구조(체스판).jpg)

- 힙 전체를 **리전(Region)** 단위로 나눠 관리 (1MB~32MB)

- 각 리전은 상황에 따라 Young / Old / Humongous 역할을 **동적으로 할당**받음

- 특정 시점에 일부 리전은 Young, 다른 리전은 Old로 쓰이는 식 → 물리적으로 고정된 구조가 아님

- GC는 리전 단위로 동작하므로, 큰 힙에서도 Stop-the-World 시간을 짧게 유지할 수 있음

- 4GB 이상의 큰 힙에서 효과적, 대규모 애플리케이션과 멀티코어 환경에 적합

- Spring Boot 3.x + Java 17 환경에서는 기본적으로 G1 GC가 사용됨


### 정리
| 구분                 | 공통 원리 (Generational GC)          | 선형 구조         | 체스판 구조 (G1 GC)       |
| ------------------ | -------------------------------- | ------------- | -------------------- |
| **세대 구분**          | Young / Old로 나눠 관리               | 물리적으로 고정된 위치  | 리전 단위로 동적 할당         |
| **객체 이동**          | Eden → Survivor → Old            | 고정된 영역 내에서 이동 | 리전 간 이동, 역할이 바뀜      |
| **GC 단위**          | Minor GC (Young), Major GC (Old) | 세대 단위         | 리전 단위                |
| **Stop-the-World** | GC 시 일시 정지 발생                    | 큰 힙에서 길어짐     | 예측 가능, 상대적으로 짧음      |
| **적합한 환경**         | 공통적으로 모든 자바 프로그램                 | 소규모 ~ 중규모     | 대규모 힙(4GB+), 멀티코어 환경 |


- **Eden, Survivor, Old, Minor GC, Major GC 개념은 선형 구조와 체스판 구조 모두에서 공통적으로 적용**

- 차이는 메모리를 **고정된 선형 구조로 관리하느냐**, **리전 단위로 동적으로 관리하느냐**

- 현대 자바(Java 9~)에서는 기본적으로 **체스판 구조(G1 GC)**가 적용되므로, 전통적인 선형 구조와 비교해 차이를 이해하고 학습하는 것이 중요
    